**Date:** 2025-08-12 
**Felicity adviced:** Transient SMB disabled (do not suggest turning smb on)  

# INITIAL PROBLEM: 
üîé **setup_non_periodic_boundary_conditions(md):**
I used to implement velocity cap due to observed extremely high velocities (Stressbalance solve shows it (transient runs crash))
this lead to:
Velocities that look too small (THIS IS EVIDENT after extracting results from nc file for complete transient evolution)
my suspicion is that there is unit conversion errors in terminus velocity estimation


# TRANSIENT RESULTS FROM USING v_est cap

## S1
```
Surface velocity ranges (m a‚Åª¬π):
  vx: [-5.12, 23.16]
  vy: [-33.41, 28.70]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S1_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[ 1.00000000e+00  1.58443823e-03  0.00000000e+00  0.00000000e+00]
 [ 9.99367889e-01 -5.96319487e-01  0.00000000e+00  0.00000000e+00]
 [ 9.98735777e-01 -1.22361929e+00  0.00000000e+00  0.00000000e+00]
 [ 9.98103666e-01 -1.79301382e+00  0.00000000e+00  0.00000000e+00]
 [ 9.97471555e-01 -2.35164526e+00  0.00000000e+00  0.00000000e+00]]
‚úì output saved: 165_S1_0.5_static.txt

```
## S2
```
Surface velocity ranges (m a‚Åª¬π):
  vx: [-3.22, 46.57]
  vy: [-91.58, 68.16]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S2_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[ 1.          0.00158444  0.          0.        ]
 [ 0.99936789 -0.13236569  0.          0.        ]
 [ 0.99873578 -0.36681776  0.          0.        ]
 [ 0.99810367 -0.55210279  0.          0.        ]
 [ 0.99747155 -0.79672088  0.          0.        ]]
‚úì output saved: 165_S2_0.5_static.txt


```

## S3
```
Surface velocity ranges (m a‚Åª¬π):
  vx: [-0.19, 40.35]
  vy: [-46.75, 39.94]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [-9.11, 36.29]
‚úì Saved 165_S3_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[ 1.00000000e+00  1.58443823e-03  0.00000000e+00  0.00000000e+00]
 [ 9.99367889e-01 -4.16687812e-02  0.00000000e+00  2.15610667e+00]
 [ 9.98735777e-01 -1.25195831e-01  0.00000000e+00  4.31356135e+00]
 [ 9.98103666e-01 -1.49318056e-01  0.00000000e+00  6.41927440e+00]
 [ 9.97471555e-01 -1.72211734e-01  0.00000000e+00  8.45916037e+00]]
‚úì output saved: 165_S3_0.5_static.txt

```
## S4
```
Surface velocity ranges (m a‚Åª¬π):
  vx: [0.00, 60.95]
  vy: [-120.97, 90.60]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [-17.26, 49.57]
‚úì Saved 165_S4_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[1.00000000e+00 1.58443823e-03 0.00000000e+00 0.00000000e+00]
 [9.99367889e-01 5.90872749e-01 0.00000000e+00 3.78759050e+00]
 [9.98735777e-01 1.03815997e+00 0.00000000e+00 7.66955877e+00]
 [9.98103666e-01 1.53935246e+00 0.00000000e+00 1.14095293e+01]
 [9.97471555e-01 1.96665975e+00 0.00000000e+00 1.50497642e+01]]
‚úì output saved: 165_S4_0.5_static.txt

```




# CURRENT PROBLEM

üîé **setup_non_periodic_boundary_conditions(md):**
DEACTIVATED velocity cap (v_est)
this lead to :
Extreme velocities (~millions m/a) in diagnostic runs leading to crashed transient runs


**Terminus Velocity Cap (LOOKS LIKE IT IS REQUIRED :( ):**
Unrealistic velocities that crash transient solver. 
## S2 example
```bash
iteration 2/1200  time [yr]: 0.50 (time step: 0.25)
   computing new velocity
computing slope...
   extruding SurfaceSlopeX from base...

[0] ??? Error using ==> ./classes/Elements/TriaRef.cpp:117
[0] GetJacobianDeterminant error message: negative jacobian determinant!

--------------------------------------------------------------------------
Primary job  terminated normally, but 1 process returned
a non-zero exit code. Per user-direction, the job has been aborted.
--------------------------------------------------------------------------

```

## Results

**Validation:**
- **S1 (n=1):** Expected 
- **S2 (n=3):** Expected 
- **S3 (n=1 + sliding):** Expected 
- **S4 (n=3 + sliding):** Expected 

## Next Steps

### Completed ‚úÖ
2. **Experiment-specific A values implemented** - using correct Pattyn 2008 values
3. **SMB approach confirmed** - zero SMB appropriate for ISMIP-HOM diagnostics
4. **Transient SMB disabled** - per supervisor guidance for benchmark focus

### Remaining Tasks
1. **Test S1 diagnostic** - completed (not obviously crashed transient solve)
2. **Test S2 diagnostic** - completed (obviously crashed transient solve timestep 2)
3. **Test S3 diagnostic** - completed (not obviously crashed transient solve timestep 2)
3. **Test S4 diagnostic** - completed (obviously crashed transient solve)

see below for terminal output for each experiment

## Session Outcome

### Original Session (2025-01-12) 
Hypothesis: The capping vel at terminus is wrong?
OLD cap in `setup_non_periodic_boundary_conditions()`
```python
beta2 = np.clip(beta2, 1e-4, None) # Stabilizing fallback: prevent div by zero

# Basal sliding estimate for terminus: v ‚âà œÑ_d / Œ≤¬≤  (from linear sliding law)
v_est = tau_d / beta2
v_est = np.clip(v_est, 0, 50000 / md.constants.yts) #<<<<< 50000 √∑ 31556926 = 0.001584438 m/s which is maybe too small?

# Apply soft outflow BC
md.stressbalance.spcvx[terminus_nodes] = v_est

print(f"Terminus BC applied:")
print(f"  Slope: {slope:.6f}")
print(f"  Driving stress: {np.mean(tau_d):.1f} Pa")
print(f"  Œ≤¬≤: {np.mean(beta2):.1e} Pa¬∑s¬∑m‚Åª¬π")
print(f"  Estimated velocity: {np.mean(v_est):.2f} m/s")
v_est_m_per_a = v_est * md.constants.yts
print(f"  Estimated velocity: {np.mean(v_est_m_per_a):.2f} m/a")
```

## Unit Analysis
## The Polyfit Calculation

```python
# x values: x_term_centered in meters (horizontal distance)
# y values: s_term in meters (surface elevation)
slope = np.polyfit(x_term_centered, s_term, 1)[0]
```

**Units Analysis:**
- `x_term_centered`: meters (horizontal position)
- `s_term`: meters (surface elevation)
- `slope`: **dimensionless** (m/m) - rise over run

This is correct!

## Driving Stress Calculation

```python
tau_d = rho * g * H * abs(slope)
```

**Units Check:**
- `rho`: 910 kg/m¬≥ (ice density)
- `g`: ~9.81 m/s¬≤ (gravity)
- `H`: meters (ice thickness)
- `slope`: dimensionless (m/m)
- **Result:** (kg/m¬≥) √ó (m/s¬≤) √ó m √ó (dimensionless) = kg/(m¬∑s¬≤) = **Pa** ‚úì

This is correct!

## Beta and Beta¬≤

In  `setup_friction` function, I can see:
```python
beta2_issm = beta2 * md.constants.yts  # Pa¬∑a¬∑m‚Åª¬π ‚Üí Pa¬∑s¬∑m‚Åª¬π
md.friction.coefficient[basal_nodes] = np.sqrt(beta2_issm)
```
So:
- `md.friction.coefficient` = ‚àö(Pa¬∑s¬∑m‚Åª¬π) = **(Pa¬∑s¬∑m‚Åª¬π)^(1/2)**
- When squared `beta2` = (Pa¬∑s¬∑m‚Åª¬π)^(1/2) √ó (Pa¬∑s¬∑m‚Åª¬π)^(1/2) = **Pa¬∑s¬∑m‚Åª¬π**

## Velocity Estimation

```python
v_est = tau_d / beta2
```

- `tau_d`: **Pa** (as already established)
- `beta2`: **Pa¬∑s¬∑m‚Åª¬π**
- `v_est` = Pa √∑ (Pa¬∑s¬∑m‚Åª¬π) = Pa √ó (m/(Pa¬∑s)) = **m/s** ‚úì

## Conversion to m/year

```python
v_est_m_per_a = v_est * md.constants.yts
```

- `v_est`: **m/s**
- `md.constants.yts`: **s/year** (31556926 s/year)
- Result: (m/s) √ó (s/year) = **m/year** ‚úì

50 km/year √∑ yts ‚âà 0.0016 m/s might be too small?

**Conclusion:** No unit conversion errors. Maybe the cap was too restrictive.

# NEXT: I turned off the velocity cap at the terminus to test if I could obtain better results but this is the output for all scenarios for profile 165

# Document final velocity ranges
## S1 static output
```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 

...

Coordinate ranges: x_hat=[0.000, 1.000],y_hat=[-0.002, 0.012]
Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [-0.12, 1846.59]
  vy: [-1334.97, 26.76]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S1_0.5_static.txt with shape (3199, 4)
First 5 rows:
[[1.00000000e+00 1.84658918e+03 0.00000000e+00 0.00000000e+00]
 [9.99374609e-01 1.84605861e+03 0.00000000e+00 0.00000000e+00]
 [9.98749218e-01 1.84488044e+03 0.00000000e+00 0.00000000e+00]
 [9.98123827e-01 1.84187275e+03 0.00000000e+00 0.00000000e+00]
 [9.97498437e-01 1.83528525e+03 0.00000000e+00 0.00000000e+00]]
‚úì output saved: 165_S1_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S1 ===
Surface elevation: 1943.400 to 1642.029 m
Bed elevation: 23.400 to -277.971 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 160 km:
  Surface: -301.371 m (-1.884 m/km)
  Bed: -301.371 m (-1.884 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51289.6 Pa
  Right (x=L): 428037.4 Pa
  Difference: 376747.8 Pa

======================================
```
## S2 static output
```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 

...

Coordinate ranges: x_hat=[0.000, 1.000],y_hat=[-0.002, 0.012]
Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [0.00, 9093875.54]
  vy: [-10032940.99, 492.77]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S2_0.5_static.txt with shape (3199, 4)
First 5 rows:
[[1.00000000e+00 8.88276852e+06 0.00000000e+00 0.00000000e+00]
 [9.99374609e-01 8.87911182e+06 0.00000000e+00 0.00000000e+00]
 [9.98749218e-01 8.88023414e+06 0.00000000e+00 0.00000000e+00]
 [9.98123827e-01 8.89196537e+06 0.00000000e+00 0.00000000e+00]
 [9.97498437e-01 8.91317337e+06 0.00000000e+00 0.00000000e+00]]
‚úì output saved: 165_S2_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S2 ===
Surface elevation: 1943.400 to 1642.029 m
Bed elevation: 23.400 to -277.971 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 160 km:
  Surface: -301.371 m (-1.884 m/km)
  Bed: -301.371 m (-1.884 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51289.6 Pa
  Right (x=L): 428037.4 Pa
  Difference: 376747.8 Pa

======================================
```

## S3 static output
```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 

...

Coordinate ranges: x_hat=[0.000, 1.000],y_hat=[-0.002, 0.012]
Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [0.00, 3235.63]
  vy: [-1569.63, 33.37]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [-2.06, 3485.88]
‚úì Saved 165_S3_0.5_static.txt with shape (3199, 4)
First 5 rows:
[[1.00000000e+00 3.23563330e+03 0.00000000e+00 0.00000000e+00]
 [9.99374609e-01 3.23411634e+03 0.00000000e+00 2.15605009e+00]
 [9.98749218e-01 3.23243588e+03 0.00000000e+00 4.31373227e+00]
 [9.98123827e-01 3.22999311e+03 0.00000000e+00 6.41270650e+00]
 [9.97498437e-01 3.22516579e+03 0.00000000e+00 8.44655546e+00]]
‚úì output saved: 165_S3_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S3 ===
Surface elevation: 1943.400 to 1642.029 m
Bed elevation: 23.400 to -277.971 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 160 km:
  Surface: -301.371 m (-1.884 m/km)
  Bed: -301.371 m (-1.884 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51289.6 Pa
  Right (x=L): 428037.4 Pa
  Difference: 376747.8 Pa

======================================

```
## S4 static output
```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 

...

Coordinate ranges: x_hat=[0.000, 1.000],y_hat=[-0.002, 0.012]
Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [0.00, 9095925.62]
  vy: [-10034150.42, 498.12]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [-2929.10, 28843.52]
‚úì Saved 165_S4_0.5_static.txt with shape (3199, 4)
First 5 rows:
[[1.00000000e+00 8.88478765e+06 0.00000000e+00 0.00000000e+00]
 [9.99374609e-01 8.88112979e+06 0.00000000e+00 3.80406456e+00]
 [9.98749218e-01 8.88225132e+06 0.00000000e+00 7.69946901e+00]
 [9.98123827e-01 8.89398307e+06 0.00000000e+00 1.14178298e+01]
 [9.97498437e-01 8.91519187e+06 0.00000000e+00 1.50487844e+01]]
‚úì output saved: 165_S4_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S4 ===
Surface elevation: 1943.400 to 1642.029 m
Bed elevation: 23.400 to -277.971 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 160 km:
  Surface: -301.371 m (-1.884 m/km)
  Bed: -301.371 m (-1.884 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51289.6 Pa
  Right (x=L): 428037.4 Pa
  Difference: 376747.8 Pa

======================================
```

# IN SUMMARY:
1. Velocities are super high now!
2. non linear transient runs crash! the linear transient runs contiue beyond timestep 2 (where non linear scenarios crash)

# Hypothesis 2: Domain Ending at Bedrock Trough
Profile 165 ends at a **trough** (low point) in bedrock undulations, creating:
- Steep upward slope at terminus
- **Massive driving stress**: 428,037 Pa at terminus vs 51,290 Pa at inlet
- Driving stress difference: **376,748 Pa** (7x difference!)
- This might be causing extreme velocities, especially with nonlinear rheology (n=3)

## Step 1: Place this after your imports but before your main simulation code:

```python
def find_optimal_domain_length(bedrock_config, target_L=160e3, search_window=5e3):
    """
    Find domain length that guarantees an integer number of bedrock periods
    and ends at/near a bedrock peak for optimal boundary conditions.
    """
    from scipy.signal import find_peaks
    
    wavelength = bedrock_config.profile_params['wavelength']
    
    # Step 1: Find the closest integer number of periods to target
    target_periods = target_L / wavelength
    n_periods_candidates = [int(np.floor(target_periods)), int(np.ceil(target_periods))]
    
    print(f"\nDomain optimization for integer periods:")
    print(f"  Target L: {target_L/1000:.1f} km")
    print(f"  Wavelength: {wavelength/1000:.1f} km")
    print(f"  Target periods: {target_periods:.2f}")
    print(f"  Candidate periods: {n_periods_candidates}")
    
    best_L = None
    best_score = float('inf')
    best_n_periods = None
    
    for n_periods in n_periods_candidates:
        if n_periods <= 0:
            continue
            
        # Exact domain length for integer periods
        L_exact = n_periods * wavelength
        
        # Search for peaks near this exact length
        search_start = max(0, L_exact - search_window/2)
        search_end = L_exact + search_window/2
        x_search = np.linspace(search_start, search_end, int(search_window / 50))  # 50m resolution
        bed_search = bedrock_config.get_bedrock_elevation(x_search)
        
        # Find peaks in this region
        peaks, properties = find_peaks(bed_search, 
                                       distance=int(0.3 * wavelength / 50))
        
        if len(peaks) == 0:
            # No peaks found, use exact integer period length
            peak_L = L_exact
            distance_from_target = abs(L_exact - target_L)
        else:
            # Find peak closest to exact integer period length
            peak_positions = x_search[peaks]
            closest_peak_idx = np.argmin(np.abs(peak_positions - L_exact))
            peak_L = peak_positions[closest_peak_idx]
            distance_from_target = abs(peak_L - target_L)
        
        # Score based on: 1) distance from target, 2) how close to exact integer periods
        period_error = abs(peak_L / wavelength - n_periods)
        score = distance_from_target + 1000 * period_error  # Heavily weight period accuracy
        
        print(f"  n={n_periods}: L={peak_L/1000:.3f} km, periods={peak_L/wavelength:.4f}, score={score:.1f}")
        
        if score < best_score:
            best_score = score
            best_L = peak_L
            best_n_periods = n_periods
    
    if best_L is None:
        # Fallback: use exact integer periods closest to target
        n_periods = round(target_periods)
        best_L = n_periods * wavelength
        best_n_periods = n_periods
        print(f"  Fallback: Using exact {n_periods} periods")
    
    # Final validation
    actual_periods = best_L / wavelength
    period_error = abs(actual_periods - best_n_periods)
    
    print(f"\nFinal domain configuration:")
    print(f"  Optimal L: {best_L/1000:.3f} km")
    print(f"  Integer periods: {best_n_periods}")
    print(f"  Actual periods: {actual_periods:.6f}")
    print(f"  Period error: {period_error:.6f}")
    print(f"  Adjustment from target: {(best_L - target_L)/1000:.3f} km")
    
    # Ensure period error is negligible (< 0.1% of a period)
    if period_error > 0.001:
        print(f"  WARNING: Period error {period_error:.6f} exceeds tolerance!")
    else:
        print(f"  ‚úì Period precision verified")
    
    return best_L
```

## Step 2: Replace GEOMETRY section

Replace this:
```python
# GEOMETRY
L = 160e3 #m
nx = 1600 #dx ‚âà 0.1 km
```

With this:
```python
# GEOMETRY
target_L = 160e3  # Target domain length (m)
target_nx = 1600  #dx ‚âà 0.1 km (Target resolution)

# Find optimal L that ends at a peak
L = find_optimal_domain_length(bedrock_config, target_L)

# Adjust nx proportionally to maintain resolution
nx = int(target_nx * L / target_L)
print(f"Adjusted nx: {nx} (maintaining ~100m resolution)")
```

## Step 3: The rest of `flowline.py` stays the same!


# Document final velocity ranges
## S1 static output
```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 
...

Coordinate ranges: x_hat=[0.000, 1.000],y_hat=[-0.002, 0.012]
Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [-0.13, 1833.32]
  vy: [-1321.27, 26.77]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S1_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[1.00000000e+00 1.83332247e+03 0.00000000e+00 0.00000000e+00]
 [9.99367889e-01 1.83328484e+03 0.00000000e+00 0.00000000e+00]
 [9.98735777e-01 1.83162514e+03 0.00000000e+00 0.00000000e+00]
 [9.98103666e-01 1.82941547e+03 0.00000000e+00 0.00000000e+00]
 [9.97471555e-01 1.82337113e+03 0.00000000e+00 0.00000000e+00]]
‚úì output saved: 165_S1_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S1 ===
Surface elevation: 1943.400 to 1668.609 m
Bed elevation: 23.400 to -251.391 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 158 km:
  Surface: -274.791 m (-1.736 m/km)
  Bed: -274.791 m (-1.736 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51298.2 Pa
  Right (x=L): 14453.5 Pa
  Difference: 36844.6 Pa

======================================

```
## S2 static output
```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 
...

Coordinate ranges: x_hat=[0.000, 1.000],y_hat=[-0.002, 0.012]
Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [0.00, 8782041.70]
  vy: [-9747241.64, 1631.49]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S2_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[1.00000000e+00 8.56001920e+06 0.00000000e+00 0.00000000e+00]
 [9.99367889e-01 8.56103817e+06 0.00000000e+00 0.00000000e+00]
 [9.98735777e-01 8.56554422e+06 0.00000000e+00 0.00000000e+00]
 [9.98103666e-01 8.58169478e+06 0.00000000e+00 0.00000000e+00]
 [9.97471555e-01 8.60573569e+06 0.00000000e+00 0.00000000e+00]]
‚úì output saved: 165_S2_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S2 ===
Surface elevation: 1943.400 to 1668.609 m
Bed elevation: 23.400 to -251.391 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 158 km:
  Surface: -274.791 m (-1.736 m/km)
  Bed: -274.791 m (-1.736 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51298.2 Pa
  Right (x=L): 14453.5 Pa
  Difference: 36844.6 Pa

======================================

===== Solving Transient Full-Stokes =====
checking model consistency
marshalling file '165_S2_0.5'.bin
uploading input file and queuing script
launching solution sequence on remote cluster

Ice-sheet and Sea-level System Model (ISSM) version  4.24
(website: http://issm.jpl.nasa.gov forum: https://issm.ess.uci.edu/forum/)

call computational core:
iteration 1/1200  time [yr]: 0.25 (time step: 0.25)
   computing new velocity
computing slope...
   extruding SurfaceSlopeX from base...
   computing slope
   computing basal mass balance
   computing basal mass balance
   computing mass transport
   call free surface computational core
   extruding Base from base...
   extruding solution from top...
   extruding solution from top...
   extruding solution from top...
   updating vertices positions
   computing transient requested outputs
   saving temporary results
iteration 2/1200  time [yr]: 0.50 (time step: 0.25)
   computing new velocity
computing slope...
   extruding SurfaceSlopeX from base...

[0] ??? Error using ==> ./classes/Elements/TriaRef.cpp:117
[0] GetJacobianDeterminant error message: negative jacobian determinant!

```
# Results with Domain Adjustment:
- Domain adjusted from 160 km to **158.3 km** (nearest peak)
- Driving stress at terminus reduced to **14,454 Pa**
- Driving stress difference reduced to **36,845 Pa** (10x improvement!)
- Terminus verification shows bed rising: -253.1m ‚Üí -251.4m ‚úì

## Diagnostic Velocities After Fix:

### Linear Rheology (n=1):
- **S1 (no slip):** ~1833 m/a ‚úì reasonable

### Nonlinear Rheology (n=3):
- **S2 (no slip):** ~8.78 million m/a ‚ùå still extreme!

## Why Still Extreme for Nonlinear?
Even with reduced driving stress, nonlinear rheology (n=3) creates exponential feedback:
- Small stress ‚Üí deformation ‚Üí faster flow ‚Üí more deformation ‚Üí RUNAWAY
- Free outflow BC allows unlimited acceleration

# FINAL SOLUTION: Two-Part Fix

## 1. Domain Adjustment ‚úÖ (Implemented)
- Ensures domain ends at bedrock peak
- Reduces driving stress at terminus
- Works well for linear rheology


# ASK FELICITY AND JASON IF THIS IS VALID

## 2. Velocity Cap for Nonlinear (Still Needed)
```python
if exp in ('S2', 'S4'):  # n=3 experiments only
    max_velocity_ma = 10000  # m/a - physically reasonable upper limit (?)
    max_velocity_ms = max_velocity_ma / md.constants.yts
    md.stressbalance.spcvx[terminus_nodes] = max_velocity_ms
```

## Physical Velocity Scale Reference:
- **Slow ice flow:** 10-100 m/a
- **Moderate flow:** 100-1000 m/a
- **Fast ice streams:** 1000-10,000 m/a
- **S1/S3 results:** 1800-3200 m/a (reasonable fast flow)
- **S2/S4 results:** ~9 million m/a (physically impossible without cap)

# Next Steps

### Completed ‚úÖ
1. **Unit analysis** - all units correct
2. **Root cause identified** - domain ending at trough
   **Domain adjustment implemented** - reduces driving stress 10x
4. **S1 diagnostic** - reasonable velocities, transient should work
5. **S2 diagnostic** - still needs velocity cap for transient
6. **S3 diagnostic** - ???
7. **S4 diagnostic** - ???

### Remaining Tasks
1. **Implement velocity cap for S2/S4** - prevent nonlinear runaway
2. **Re-test S2 transient** with both fixes
3. **Re-test S2 transient** with both fixes
4. **Re-test S4 transient** with both fixes
5. verify velocities!


Setting cap to 10 000 m/a
```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 

...

Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [-3.22, 46.57]
  vy: [-91.58, 68.16]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S2_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[ 1.00000000e+00  3.16887646e-04  0.00000000e+00  0.00000000e+00]
 [ 9.99367889e-01 -1.33640375e-01  0.00000000e+00  0.00000000e+00]
 [ 9.98735777e-01 -3.68097801e-01  0.00000000e+00  0.00000000e+00]
 [ 9.98103666e-01 -5.53388462e-01  0.00000000e+00  0.00000000e+00]
 [ 9.97471555e-01 -7.98010384e-01  0.00000000e+00  0.00000000e+00]]
‚úì output saved: 165_S2_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S2 ===
Surface elevation: 1943.400 to 1668.609 m
Bed elevation: 23.400 to -251.391 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 158 km:
  Surface: -274.791 m (-1.736 m/km)
  Bed: -274.791 m (-1.736 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51298.2 Pa
  Right (x=L): 14453.5 Pa
  Difference: 36844.6 Pa

======================================

```

setting cap to 100 000m/a

```
(.venv) ana@MU00236940:~/Desktop/code/Gadi/flowline$ python flowline.py 

...

Coordinate ranges: x_hat=[0.000, 1.000],y_hat=[-0.002, 0.012]
Warning: No Vz field found, using zeros
Surface velocity ranges (m a‚Åª¬π):
  vx: [-3.22, 46.57]
  vy: [-91.58, 68.16]
  vz: [0.00, 0.00]
Basal velocity ranges (m a‚Åª¬π):
  vx_basal: [0.00, 0.00]
‚úì Saved 165_S2_0.5_static.txt with shape (3165, 4)
First 5 rows:
[[ 1.          0.00316888  0.          0.        ]
 [ 0.99936789 -0.13077225  0.          0.        ]
 [ 0.99873578 -0.36521755  0.          0.        ]
 [ 0.99810367 -0.55049548  0.          0.        ]
 [ 0.99747155 -0.79510868  0.          0.        ]]
‚úì output saved: 165_S2_0.5_static.txt

=== DRIVING STRESS DIAGNOSTIC S2 ===
Surface elevation: 1943.400 to 1668.609 m
Bed elevation: 23.400 to -251.391 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 158 km:
  Surface: -274.791 m (-1.736 m/km)
  Bed: -274.791 m (-1.736 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51298.2 Pa
  Right (x=L): 14453.5 Pa
  Difference: 36844.6 Pa

======================================
```
The velocity cap IS working, but it's causing unexpected behavior for the nonlinear (n=3) scenarios

### Without cap (original problem):
- **S2 velocities:** ~8.78 million m/a ‚ùå (physically impossible)

### With 10,000 m/a cap:
- **S2 velocities:** max ~46.57 m/a ‚úì (but suspiciously low)

### With 100,000 m/a cap:  
- **S2 velocities:** max ~46.57 m/a ‚úì (identical to 10,000 cap!)

## AI diagnostic of the issue

**Over-constraining** the nonlinear system. By prescribing a fixed velocity at the terminus for n=3, you're creating a boundary condition that conflicts with the natural stress solution. The nonlinear rheology is extremely sensitive to stress, and forcing a specific velocity at both inlet (v=0) and terminus (v=cap) makes the solver struggle to find a consistent solution.

## Why This Happens with n=3 but not n=1

- **Linear rheology (n=1):** Stress and strain rate are linearly related, so the system can smoothly adjust
- **Nonlinear rheology (n=3):** Small stress changes cause large velocity changes (œÑ ‚àù ŒµÃá^(1/3)), making the system very sensitive to boundary constraints

## Better Solution: Stress-Based BC Instead of Velocity Cap

Instead of prescribing velocity, apply a **stress boundary condition** at the terminus:

```python
def setup_non_periodic_boundary_conditions(md):
    """
    Apply non-periodic BCs with stress-based terminus condition
    """
    print("\n============ SETTING NON-PERIODIC BCS ==============")
    
    inlet_nodes = np.where(md.mesh.vertexflags(4))[0]  
    terminus_nodes = np.where(md.mesh.vertexflags(2))[0]
    
    # Dirichlet inlet boundary (keep this)
    md.stressbalance.spcvx[inlet_nodes] = 0.0
    
    # For nonlinear experiments, use stress BC instead of velocity cap
    if exp in ('S2', 'S4'):

        # Option 2:
        # Basal sliding estimate: v ‚âà œÑ_d / Œ≤¬≤  (from linear sliding law)
        v_est = tau_d / beta2
        v_est = np.clip(v_est, 0, 50000 / md.constants.yts)  # e.g. max 10000 m/a <<<< CHECK NO LIMIT 

        # Deformation-dominated cases (S1/S2) ‚Üí expected velocities ~ small
        if np.allclose(beta2, 1e8, atol=1e5):  # heuristic: high Œ≤¬≤ = frozen bed
            v_est[:] = 0.01  # small outflow for stability

        # Apply soft outflow BC
        md.stressbalance.spcvx[terminus_nodes] = v_est

        print(f"Terminus BC applied:")
        print(f"  Slope: {slope:.6f}")
        print(f"  Driving stress: {np.mean(tau_d):.1f} Pa")
        print(f"  Œ≤¬≤: {np.mean(beta2):.1e} Pa¬∑s¬∑m‚Åª¬π")
        print(f"  Estimated velocity: {np.mean(v_est):.2f} m/s")
        v_est_m_per_a = v_est * md.constants.yts
        print(f"  Estimated velocity: {np.mean(v_est_m_per_a):.2f} m/a")
      
    return md
```

## Immediate Fix to Test

To double check I tried once again running S2 with **NO terminus velocity constraint** at all:
this yields:
```
Surface velocity ranges (m a‚Åª¬π):
  vx: [0.00, 8782041.70]
  vy: [-9747241.64, 1631.49]
  vz: [0.00, 0.00]

```
‚ö†Ô∏èThe fact that S2 gives either millions (uncapped) or ~46 (capped) suggests the boundary condition approach needs revision.
My results in ISMIP-HOM for experiments A, B, C and D all satified vel<100m/s (as per the Pattyn 2008 paper)
This is why I originally decided to cap the velocities ... I capped and noticed that the range of velocity outputs vere similar to those in ISMIP HOM. (i did not cap ismip-hom sims at all because I instead used periodic BCs as per the paper)


===================================================================================================================

## Questions for Felicity and Jason

1. **Is a velocity cap at the terminus physically appropriate for ISMIP-HOM benchmarks?**
My driving stress looks problematic and it was preventing me from setting periodic BCS like in ISMIP-HOM
```
=== DRIVING STRESS DIAGNOSTIC S2 ===
Surface elevation: 1943.400 to 1668.609 m
Bed elevation: 23.400 to -251.391 m
Ice thickness: 1920.000 to 1920.000 m

Systematic trends over 158 km:
  Surface: -274.791 m (-1.736 m/km)
  Bed: -274.791 m (-1.736 m/km)
  Thickness: 0.000 m (0.000 m/km)

Driving stress at boundaries:
  Left (x=0): 51298.2 Pa
  Right (x=L): 14453.5 Pa
  Difference: 36844.6 Pa
```
2. **For non-periodic domains, should I use stress BCs at the terminus instead?** 

3. **Are the extreme velocities without caps indicating a different problem?** Perhaps the domain adjustment alone isn't sufficient.

4. **WHAT ARE REASONABLE VELOCITIES???**