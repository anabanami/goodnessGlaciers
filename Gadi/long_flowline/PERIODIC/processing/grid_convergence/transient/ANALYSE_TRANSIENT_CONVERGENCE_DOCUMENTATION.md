# analyse_transient_convergence.py Documentation

**Version:** Enhanced with velocity evolution tracking (2025-08-27)  
**Purpose:** Grid independence study analysis for transient ice flow simulations with time-series tracking  
**Location:** `/processing/grid_convergence/transient/analyse_transient_convergence.py`

## Overview

This script performs comprehensive grid convergence analysis for transient ice flow simulations generated by ISSM. It compares final steady states from different mesh resolutions to determine optimal computational settings for ice sheet modeling.

## Key Features

### 1. Automatic Dataset Detection
- **Auto-detection:** Automatically finds and groups NetCDF files by profile ID and experiment type
- **Pattern matching:** Supports multiple filename formats (e.g., `165_S1_1.0.nc`, `165_S1_1.0_final_time=*_timestep=*.nc`)
- **Multi-experiment support:** Handles S1, S2, S3, S4 experiment types simultaneously

### 2. Units-Aware Data Loading ⚡ **FIXED**
The script now correctly handles ISSM's SI unit outputs:

```python
def convert_velocity_units(self, var, data):
    """Convert velocity from m/s to m/year if needed."""
    units = getattr(var, 'units', '').lower()
    if ('m/s' in units) or ('m s-1' in units) or ('m s^-1' in units) or units == '':
        converted = data * 31556926  # Convert m/s to m/year
        # Clean up any extreme values from NaN/inf conversion
        converted = np.where(np.abs(converted) > 1e6, 0, converted)
        return converted
    return data

def convert_time_units(self, var, data):
    """Convert time from seconds to years if needed."""
    units = getattr(var, 'units', '').lower()
    if 'sec' in units or units == '':
        return data / 31556926  # Convert seconds to years
    elif 'yr' in units or 'year' in units:
        return data  # Already in years
    else:
        return data / 31556926  # Safe fallback
```

### 3. Mesh Reconstruction
- **Coordinate reconstruction:** Rebuilds spatial coordinates using bedrock configuration
- **Resolution matching:** Adapts mesh density based on resolution factors
- **Validation:** Checks and handles mesh/data dimension mismatches

### 4. Grid Convergence Metrics
Calculates standard convergence metrics with configurable tolerances:
- **L2 relative error:** `||v_fine - v_coarse|| / ||v_fine||`
- **Maximum relative error:** Point-wise maximum differences
- **RMSE:** Root mean square error in absolute units
- **Convergence assessment:** Pass/fail based on user-defined tolerance
- **Tolerance parameters:**
  - `relative_tolerance = 0.01` (1% for relative errors)
  - `absolute_tolerance = 0.01` (0.01 m/a for absolute errors)
  - `near_zero_threshold = 0.1` (0.1 m/a threshold for switching to absolute metrics)

### 5. Velocity Evolution Tracking ⚡ **NEW**
- **Time-series analysis:** Tracks maximum velocity evolution over time
- **Evolution data storage:** Maintains separate dictionary for temporal data
- **Multi-resolution tracking:** Compares evolution across different mesh resolutions
- **Integration with plotting:** Automatic visualization of temporal evolution

### 6. Data Quality Validation
- **NaN/Inf detection:** Identifies invalid values in velocity fields
- **Coordinate overlap:** Ensures proper spatial coverage between resolutions
- **Steady state assessment:** Checks if simulations reached equilibrium

## Usage

### Basic Usage
```bash
# Auto-detect all datasets and analyze final states only
python analyse_transient_convergence.py --auto --final_time_only

# Auto-detect with full time series analysis
python analyse_transient_convergence.py --auto

# Manual specification
python analyse_transient_convergence.py --profile_id 165 --experiment S1
```

### Command Line Options
- `--auto`: Automatically detect profile, experiment, and resolution factors
- `--final_time_only`: Analyze only final time states (faster)
- `--profile_id XXX`: Specify bedrock profile ID
- `--experiment SX`: Specify experiment type (S1, S2, S3, S4)
- `--resolution_factors X.X X.X`: Custom resolution factors
- `--tolerance 0.01`: Convergence tolerance (default: 1%)

## Experiment Types

The script handles four standard ice flow experiment configurations:

| Experiment | Basal Conditions | Ice Rheology | Purpose |
|------------|------------------|--------------|---------|
| **S1** | No-slip (frozen bed) | Linear (n=1) | Simple reference case |
| **S2** | No-slip (frozen bed) | Non-linear (n=3) | Rheology effects |
| **S3** | Basal sliding | Linear (n=1) | Sliding mechanics |
| **S4** | Basal sliding | Non-linear (n=3) | Full complexity |

## Output Files

### 1. Convergence Report
**Filename:** `{profile_id}_{experiment}_transient_convergence_report.md`

Contains:
- Results summary (mesh statistics, simulation duration)
- Convergence metrics for each resolution factor
- Pass/fail assessment for each variable
- Recommendations for optimal resolution

### 2. Visualization Plots
**Filename:** `{profile_id}_{experiment}_transient_convergence_plots.png`

Four-panel figure with:
- **Surface velocity comparison:** Final velocity profiles across all resolutions
- **Basal velocity comparison:** Sliding velocities across all resolutions  
- **Convergence metrics:** L2 relative errors with 1% threshold line (log scale)
- **Velocity evolution:** ⚡ **NEW** Maximum velocity evolution over time for all resolutions

## Technical Details

### File Structure Support
```
transient/
├── S1/
│   ├── 165_S1_0.5.nc
│   ├── 165_S1_0.75.nc
│   ├── 165_S1_1.0.nc
│   └── 165_S1_1.25.nc
├── S2/
│   └── ...
└── analyse_transient_convergence.py
```

### NetCDF Data Structure
Expected NetCDF structure from ISSM export:
```
results/
└── TransientSolution/
    ├── time[Time] (seconds → converted to years)
    ├── Vx[Time, VertNum, 1] (m/s → converted to m/year)
    ├── Vy[Time, VertNum, 1] (m/s → converted to m/year)
    ├── Surface[Time, VertNum, 1]
    └── Base[Time, VertNum, 1]
```

## Core Methods

### 1. `load_velocity_evolution(resolution_factors)` ⚡ **NEW**
Loads time-series velocity evolution data from NetCDF files for temporal analysis.

**Parameters:**
- `resolution_factors`: List of resolution factors to analyze

**Functionality:**
- Extracts full time-series data from NetCDF `TransientSolution` group
- Converts time from seconds to years using `self.yts = 31556926`
- Converts velocity from m/s to m/a (multiply by `yts`)
- Calculates maximum velocity at each timestep: `max_vx_evolution = np.max(vx_all_times, axis=1)`
- Stores data in `self.evolution_data[res_factor]` dictionary
- Provides detailed progress logging

**Output Structure:**
```python
self.evolution_data[res_factor] = {
    'time_years': time_data_years,    # Time array in years
    'max_vx': max_vx_evolution,       # Maximum velocity at each timestep
}
```

### 2. Enhanced Flowband Centerline Extraction
The script now implements sophisticated centerline extraction for flowband models:

**Multi-method approach:**
1. **Mesh structure detection:** Attempts to identify mesh dimensions (e.g., 14479×3, 3×14479)
2. **Centerline identification:** Extracts middle row/column based on mesh layout
3. **Validation against static data:** Compares with reference static solution using RMSE
4. **Fallback method:** Uses nodes 2000-4099 if automatic detection fails

**Key improvements:**
- Handles 43,437 total nodes with various factorizations
- Validates extraction quality with static solution comparison
- Provides detailed logging of extraction process
- Robust fallback mechanisms for edge cases

### Dependencies
```python
import numpy as np
import matplotlib.pyplot as plt
import netCDF4 as nc
from scipy.signal import find_peaks  # Optional
from bedrock_generator import SyntheticBedrockModelConfig  # Optional
from bamgflowband import bamgflowband  # Optional
```

## Performance Considerations

### Memory Optimization
- **Final time only:** Use `--final_time_only` for large datasets
- **Interpolation:** Automatic grid interpolation for different resolutions
- **Data validation:** Early detection of dimension mismatches

### Computational Scaling
The script tracks relative computational cost based on:
```python
relative_cost = (n_points * n_timesteps) / (min_points * min_timesteps)
```

## Error Handling

### Common Issues and Solutions

1. **Dimension Mismatch**
   ```
   Warning: Mesh reconstruction gave X points, but NetCDF has Y points
   Using interpolation to match NetCDF data structure
   ```
   *Solution:* Automatic interpolation handles this gracefully

2. **Missing Dependencies**
   ```
   Warning: bedrock_generator not available. Mesh reconstruction will use simplified domain calculation.
   ```
   *Solution:* Falls back to simplified coordinate reconstruction

3. **Units Conversion Issues**
   ```
   Velocity conversion: 9.97e+36 -> 314597... m/year (max vx)
   ```
   *Solution:* Automatic capping of extreme values from NaN/inf

## Validation Results

### Before Units Fix
```
Final velocities: max |vx_surface| = 1.07e-07 m/a
L2 relative error: 73.49% (comparing noise-level values)
RMSE: 0.00 m/a
```

### After Units Fix ✅
```
Final velocities: max |vx_surface| = 3.38e+00 m/a
L2 relative error: 73.49% (meaningful grid dependence)
RMSE: 1.28 m/a (actual velocity differences)
Simulation time: 300.0 years (correct duration)
```

## Best Practices

### 1. File Organization
- Keep NetCDF files in experiment subdirectories (S1/, S2/, etc.)
- Use consistent naming: `{profile_id}_{experiment}_{resolution_factor}.nc`

### 2. Analysis Workflow
1. Run with `--auto --final_time_only` for quick assessment
2. Check convergence report for optimal resolution recommendation
3. Re-run without `--final_time_only` for detailed time evolution analysis

### 3. Interpretation
- **L2 errors < 1%:** Grid converged for engineering accuracy
- **L2 errors 1-5%:** Acceptable for most glaciological applications
- **L2 errors > 10%:** Consider finer mesh resolution

## Integration with ISSM Workflow

This script is designed to work seamlessly with:
1. **flowline.py:** ISSM simulation setup
2. **export_netCDF():** ISSM results export
3. **extract_results_fixed.py:** Visualization of results

The complete workflow:
```bash
# 1. Run simulations
python flowline.py  # (with different resolution_factor values)

# 2. Analyze convergence (with time evolution)
python analyse_transient_convergence.py --auto

# 3. Quick convergence check (final state only)
python analyse_transient_convergence.py --auto --final_time_only

# 4. Visualize results
python extract_results_fixed.py --pattern='165_S*_*.nc'
```

### Updated Analysis Pipeline ⚡ **NEW**
The main analysis function now includes velocity evolution tracking:

```python
def main():
    analyser = TransientConvergenceAnalyzer()
    resolution_factors = analyser.auto_configure()
    analyser.load_transient_results(resolution_factors)    # Load final states
    analyser.load_velocity_evolution(resolution_factors)   # Load time series ← NEW
    analyser.calculate_convergence_metrics()
    converged = analyser.assess_convergence()
    analyser.generate_report(converged)
    analyser.create_comparison_plots()                     # Now includes evolution plot
```

---
*Documentation updated on 2025-08-27 to reflect velocity evolution tracking enhancements*