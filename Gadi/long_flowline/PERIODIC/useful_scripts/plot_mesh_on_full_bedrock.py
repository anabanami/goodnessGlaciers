#!/usr/bin/env python3
"""
Plot the ice mesh (as generated by flowline.py) overlaid on the FULL bedrock domain.
This shows exactly how much of the bedrock topography the simulation covers.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.tri as tri
import sys
import os

# Add current directory to path for imports
sys.path.append('.')
from bedrock_generator import SyntheticBedrockModelConfig
from bamgflowband import bamgflowband
from model import model


def get_full_bedrock_domain(bedrock_config, max_extent_km=210):
    """Get the full bedrock domain (e.g., up to 210km)"""
    print(f"Generating full bedrock domain up to {max_extent_km} km...")
    
    # Create high-resolution x array for full domain
    dx = 0.1  # 100m resolution
    nx_full = int(max_extent_km * 1000 / (dx * 1000)) + 1
    x_full = np.linspace(0, max_extent_km * 1000, nx_full)  # meters
    
    # Get bedrock elevation for full domain
    bed_full = bedrock_config.get_bedrock_elevation(x_full)
    
    return x_full / 1000, bed_full  # Return in km


def generate_simulation_mesh(profile_id, resolution_factor=1.25):
    """Generate the exact mesh used in flowline.py simulation"""
    print(f"Generating simulation mesh for profile {profile_id}...")
    
    # Load bedrock config
    bedrock_config = SyntheticBedrockModelConfig(profile_id=profile_id)
    
    # Domain optimization (same as flowline.py)
    L = 210e3  # meters
    # Adjust nx proportionally to maintain resolution (same as flowline.py)
    nx = int(L * 0.01) 
    
    print(f"Simulation domain: {L/1000:.3f} km ({nx} points)")
    
    # Create 1D profile for mesh generation
    x_1D = np.linspace(0, L, nx)
    b = bedrock_config.get_bedrock_elevation(x_1D)
    s0 = b + bedrock_config.ice_thickness
    
    # Adaptive mesh parameters (same as flowline.py)
    bed_wavelength = bedrock_config.profile_params['wavelength']
    ice_thickness = bedrock_config.ice_thickness
    
    if bed_wavelength < 15000:
        refinement_factor = 50
    else:
        refinement_factor = 200
    
    hmax = (bed_wavelength / refinement_factor) * resolution_factor
    
    print(f"Mesh parameters: wavelength={bed_wavelength/1000:.1f}km, hmax={hmax:.1f}m")
    
    # Generate mesh using bamgflowband (same as flowline.py)
    md = bamgflowband(None, x_1D, s0, b,
                      'hmax', hmax,
                      'anisomax', 3,
                      'vertical', 1)
    
    nv = md.mesh.numberofvertices
    ne = md.mesh.numberofelements
    
    print(f"Generated mesh: {nv} vertices, {ne} elements")
    
    return md, bedrock_config, L, x_1D, b, s0


def plot_mesh_on_full_bedrock(profile_id, resolution_factor=1.25, max_extent_km=210, 
                              save_plot=True, show_plot=False):
    """Plot simulation mesh overlaid on full bedrock domain"""
    
    print(f"\n=== PLOTTING MESH ON FULL BEDROCK ===")
    print(f"Profile ID: {profile_id}")
    print(f"Resolution factor: {resolution_factor}")
    print(f"Max bedrock extent: {max_extent_km} km")
    
    # Generate simulation mesh
    md, bedrock_config, L_sim, x_1D, bed_sim, surf_sim = generate_simulation_mesh(profile_id, resolution_factor)
    
    # Get full bedrock domain
    x_full_km, bed_full = get_full_bedrock_domain(bedrock_config, max_extent_km)
    
    # Extract mesh coordinates
    x_mesh = md.mesh.x / 1000  # Convert to km
    y_mesh = md.mesh.y / 1000  # Convert to km
    elements = md.mesh.elements - 1  # Convert to 0-based indexing
    
    # Create triangulation for mesh
    triang = tri.Triangulation(x_mesh, y_mesh, triangles=elements)
    
    # Create the plot
    fig, ax = plt.subplots(figsize=(16, 8))
    
    # 1. Plot FULL bedrock domain as background
    ax.plot(x_full_km, bed_full, 'k-', linewidth=1, alpha=0.7, 
            label=f'Full bedrock domain (0-{max_extent_km}km)')
    
    # 2. Plot simulation bedrock (1D profile used for mesh generation)
    x_sim_km = x_1D / 1000
    ax.plot(x_sim_km, bed_sim, 'r-', linewidth=2, 
            label=f'Simulation bedrock profile (0-{L_sim/1000:.1f}km)')
    
    # 3. Plot simulation surface
    ax.plot(x_sim_km, surf_sim, 'b-', linewidth=2, 
            label=f'Ice surface (thickness={bedrock_config.ice_thickness/1000:.1f}km)')
    
    # 4. Fill ice thickness
    ax.fill_between(x_sim_km, bed_sim, surf_sim, alpha=0.3, color='lightblue', 
                    label='Ice thickness')
    
    # 5. Plot mesh overlay (show triangulation)
    ax.triplot(triang, 'g-', linewidth=0.3, alpha=0.6, label='Finite element mesh')
    
    # 6. Mark domain boundaries
    ax.axvline(x=0, color='purple', linestyle='--', linewidth=2, alpha=0.8, 
               label='Simulation start')
    ax.axvline(x=L_sim/1000, color='purple', linestyle='--', linewidth=2, alpha=0.8,
               label=f'Simulation end ({L_sim/1000:.1f}km)')
    
    # Add bedrock wavelength indicators
    wavelength_km = bedrock_config.profile_params['wavelength'] / 1000
    n_periods = L_sim / bedrock_config.profile_params['wavelength']
    
    # Mark wavelength multiples within simulation domain
    for i in range(1, int(n_periods) + 1):
        x_period = i * wavelength_km
        if x_period <= L_sim/1000:
            ax.axvline(x=x_period, color='orange', linestyle=':', alpha=0.5, linewidth=1)
    
    # Formatting
    ax.set_xlabel('Distance (km)', fontsize=12)
    ax.set_ylabel('Elevation (m)', fontsize=12)
    ax.set_title(f'Profile {profile_id}: Ice Mesh on Full Bedrock Domain\n'
                 f'Wavelength: {wavelength_km:.1f}km, Periods in simulation: {n_periods:.1f}, '
                 f'Vertices: {md.mesh.numberofvertices}', fontsize=14)
    
    ax.grid(True, alpha=0.3)
    ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
    
    # Set sensible axis limits
    ax.set_xlim(0, max_extent_km)
    
    # Y-limits: show bedrock variation plus ice
    bed_min = np.min(bed_full)
    surf_max = np.max(surf_sim)
    y_range = surf_max - bed_min
    ax.set_ylim(bed_min - 0.1*y_range, surf_max + 0.1*y_range)
    
    # Add text box with key info
    info_text = (f"Simulation domain: 0 → {L_sim/1000:.1f} km\n"
                 f"Full bedrock: 0 → {max_extent_km} km\n"
                 f"Coverage: {100*L_sim/(max_extent_km*1000):.1f}% of full domain\n"
                 f"Mesh vertices: {md.mesh.numberofvertices:,}\n"
                 f"Resolution factor: {resolution_factor}")
    
    props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
    ax.text(0.02, 0.98, info_text, transform=ax.transAxes, fontsize=10,
            verticalalignment='top', bbox=props)
    
    plt.tight_layout()
    
    if save_plot:
        filename = f"mesh_on_full_bedrock_profile_{profile_id:03d}_res_{resolution_factor}.png"
        plt.savefig(filename, dpi=300, bbox_inches='tight')
        print(f"✅ Plot saved: {filename}")
    
    if show_plot:
        plt.show()
    else:
        plt.close()
    
    # Print summary
    print(f"\n=== SUMMARY ===")
    print(f"Full bedrock domain: 0 → {max_extent_km} km")
    print(f"Simulation domain: 0 → {L_sim/1000:.3f} km")
    print(f"Coverage: {100*L_sim/(max_extent_km*1000):.1f}% of full bedrock")
    print(f"Bedrock wavelength: {wavelength_km:.1f} km")
    print(f"Periods in simulation: {n_periods:.3f}")
    print(f"Mesh vertices: {md.mesh.numberofvertices:,}")


def main():
    """Main function - can be called with command line arguments"""
    
    # Default parameters
    profile_id = 165
    resolution_factor = 1.25
    max_extent_km = 210
    
    # Parse command line arguments if provided
    if len(sys.argv) > 1:
        profile_id = int(sys.argv[1])
    if len(sys.argv) > 2:
        resolution_factor = float(sys.argv[2])
    if len(sys.argv) > 3:
        max_extent_km = float(sys.argv[3])
    
    # Generate the plot
    plot_mesh_on_full_bedrock(profile_id, resolution_factor, max_extent_km, 
                              save_plot=True, show_plot=False)


if __name__ == "__main__":
    main()